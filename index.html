<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Plataformas V4.0 - Responsivo Total</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
    const config = {
        type: Phaser.AUTO,
        scale: {
            mode: Phaser.Scale.RESIZE, // Ocupa el 100% de la pantalla sea cual sea
            autoCenter: Phaser.Scale.CENTER_BOTH
        },
        input: { activePointers: 4 }, // Multitouch
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 1500 },
                debug: false
            }
        },
        scene: { preload: preload, create: create, update: update }
    };

    // VARIABLES
    let player, platforms, cursors, door;
    let ghosts, rocks, spikes;
    let uiContainer;
    
    // UI ELEMENTS (Para poder moverlos si la pantalla gira)
    let btnLeft, btnRight, btnJump, btnFire;
    let txtLives, txtAmmo, bgBar;

    // ESTADO
    let lives = 3;
    let ammo = 10;
    let lastFired = 0;
    let isGameOver = false;
    
    // CONTROLES
    let moveLeft = false, moveRight = false, jump = false, shoot = false;
    let facingRight = true; 

    const game = new Phaser.Game(config);

    function preload() {
        this.load.image('sky', 'https://labs.phaser.io/assets/skies/space3.png');
        this.load.image('ground', 'https://labs.phaser.io/assets/sprites/platform.png');
        this.load.spritesheet('dude', 'https://labs.phaser.io/assets/sprites/dude.png', { frameWidth: 32, frameHeight: 48 });
    }

    function create() {
        // --- 1. TEXTURAS AL VUELO ---
        let g = this.make.graphics({x:0, y:0, add: false});
        
        // Fantasma
        g.fillStyle(0xffffff, 0.9); g.fillCircle(20, 20, 20); g.generateTexture('ghostTex', 40, 40);
        // Roca
        g.clear(); g.fillStyle(0x888888, 1); g.fillCircle(10, 10, 10); g.generateTexture('rockTex', 20, 20);
        // Pincho
        g.clear(); g.fillStyle(0xff0000, 1); g.beginPath(); g.moveTo(0, 40); g.lineTo(20, 0); g.lineTo(40, 40); g.closePath(); g.fillPath(); g.generateTexture('spikeTex', 40, 40);

        // --- 2. MUNDO INFINITO ---
        // Creamos un mundo ancho para que haya nivel que recorrer
        const worldWidth = 3000; 
        const worldHeight = 1000; // Altura suficiente
        this.physics.world.setBounds(0, 0, worldWidth, worldHeight);

        // Fondo Parallax
        this.add.tileSprite(0, 0, worldWidth, worldHeight, 'sky').setOrigin(0, 0).setScrollFactor(0.5);

        // --- 3. PLATAFORMAS ---
        platforms = this.physics.add.staticGroup();
        spikes = this.physics.add.staticGroup();

        // Suelo Base (A una altura fija, no depende de la pantalla)
        const floorY = 800; 
        platforms.create(worldWidth/2, floorY, 'ground').setScale(20, 4).refreshBody();

        // Nivel
        createLevel(floorY);

        // --- 4. JUGADOR ---
        player = this.physics.add.sprite(100, floorY - 200, 'dude');
        player.setBounce(0.1);
        player.setCollideWorldBounds(true);

        this.anims.create({ key: 'left', frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }), frameRate: 10, repeat: -1 });
        this.anims.create({ key: 'turn', frames: [ { key: 'dude', frame: 4 } ], frameRate: 20 });
        this.anims.create({ key: 'right', frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }), frameRate: 10, repeat: -1 });

        // --- 5. ENTIDADES ---
        rocks = this.physics.add.group({ defaultKey: 'rockTex', maxSize: 20 });
        ghosts = this.physics.add.group();
        
        spawnGhost(600, floorY - 200);
        spawnGhost(1200, floorY - 300);
        spawnGhost(1900, floorY - 400);

        // --- 6. COLISIONES ---
        this.physics.add.collider(player, platforms);
        this.physics.add.collider(ghosts, platforms);
        this.physics.add.collider(rocks, platforms, (r) => r.destroy());
        this.physics.add.overlap(player, spikes, takeDamage, null, this);
        this.physics.add.overlap(player, ghosts, takeDamage, null, this);
        this.physics.add.overlap(rocks, ghosts, killGhost, null, this);
        this.physics.add.overlap(player, door, winGame, null, this);

        // --- 7. CMARA ---
        this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
        this.cameras.main.startFollow(player, true, 0.08, 0.08);

        // --- 8. CONTROLES ---
        cursors = this.input.keyboard.createCursorKeys();
        
        // --- 9. INTERFAZ RESPONSIVA ---
        createInterface(this);
        
        // EVENTO MGICO: Si cambia el tama帽o de pantalla, reacomodamos los botones
        this.scale.on('resize', resizeGame, this);
    }

    // Funci贸n que se ejecuta al girar el celular o cambiar tama帽o de ventana
    function resizeGame(gameSize) {
        const width = gameSize.width;
        const height = gameSize.height;

        // Reposicionar botones
        // Izquierda (Fijos a la izquierda)
        if(btnLeft) btnLeft.setPosition(80, height - 80);
        if(btnRight) btnRight.setPosition(220, height - 80);

        // Derecha (Calculados restando al ancho total)
        if(btnJump) btnJump.setPosition(width - 80, height - 80);
        if(btnFire) btnFire.setPosition(width - 220, height - 80);

        // Barra negra de fondo
        if(bgBar) {
            bgBar.clear();
            bgBar.fillStyle(0x111111, 0.8);
            bgBar.fillRect(0, height - 150, width, 150);
            bgBar.lineStyle(4, 0x00ff00);
            bgBar.lineBetween(0, height - 150, width, height - 150);
        }
        
        // Textos superiores
        if(txtAmmo) txtAmmo.x = width - 180;
    }

    function createInterface(scene) {
        uiContainer = scene.add.container(0, 0).setScrollFactor(0).setDepth(999);
        const w = scene.scale.width;
        const h = scene.scale.height;

        // Barra fondo (inicial)
        bgBar = scene.add.graphics();
        uiContainer.add(bgBar);

        // Textos
        txtLives = scene.add.text(20, 20, 'VIDAS: 3', { fontSize: '24px', color: '#ff0000', fontStyle: 'bold' });
        txtAmmo = scene.add.text(w - 180, 20, 'ROCAS: 10', { fontSize: '24px', color: '#fff', fontStyle: 'bold' });
        uiContainer.add([txtLives, txtAmmo]);

        // CREACIN DE BOTONES
        // Nota: Las posiciones Y se actualizan en resizeGame, aqu铆 ponemos valores iniciales
        
        // Bot贸n Izquierda
        btnLeft = createBtn(scene, '<', 0x333333, () => moveLeft=true, () => moveLeft=false);
        // Bot贸n Derecha
        btnRight = createBtn(scene, '>', 0x333333, () => moveRight=true, () => moveRight=false);
        // Bot贸n Salto
        btnJump = createBtn(scene, 'JUMP', 0xaa0000, () => jump=true, () => jump=false);
        // Bot贸n Disparo
        btnFire = createBtn(scene, 'O', 0x555555, () => shoot=true, () => shoot=false);

        uiContainer.add([btnLeft, btnRight, btnJump, btnFire]);

        // Llamamos a resize una vez para poner todo en su lugar
        resizeGame(scene.scale);
    }

    function createBtn(scene, text, color, downFn, upFn) {
        let container = scene.add.container(0, 0);
        let c = scene.add.circle(0, 0, 45, color).setStrokeStyle(3, 0xffffff);
        let t = scene.add.text(-15, -15, text, { fontSize: '24px', fontStyle: 'bold' });
        if(text.length > 2) t.x = -28; 

        let hit = scene.add.circle(0, 0, 60, 0x000000, 0).setInteractive();
        hit.on('pointerdown', () => { downFn(); container.y += 5; });
        hit.on('pointerup', () => { upFn(); container.y -= 5; });
        hit.on('pointerout', () => { upFn(); container.y -= 5; });

        container.add([c, t, hit]);
        return container;
    }

    function createLevel(floorY) {
        const p = platforms;
        const s = spikes;

        // Escalones
        p.create(400, floorY - 150, 'ground');
        p.create(700, floorY - 300, 'ground');
        
        // Trampa
        p.create(1100, floorY - 200, 'ground');
        s.create(1100, floorY - 232, 'spikeTex');

        // Muro alto
        p.create(1500, floorY - 400, 'ground');
        p.create(1800, floorY - 150, 'ground');

        // Meta
        const endX = 2800;
        const endY = floorY - 300;
        p.create(endX, endY + 50, 'ground').setScale(3,1).refreshBody();

        door = this.add.container(endX, endY);
        let dFrame = this.add.rectangle(0, 0, 60, 90, 0x555555).setStrokeStyle(3, 0xaaaaaa);
        let dInner = this.add.rectangle(0, 0, 50, 80, 0x220000);
        let dKnob = this.add.circle(20, 5, 5, 0xffd700);
        door.add([dFrame, dInner, dKnob]);
        this.physics.world.enable(door);
        door.body.setAllowGravity(false);
        door.body.setImmovable(true);
    }

    function spawnGhost(x, y) {
        let g = ghosts.create(x, y, 'ghostTex');
        g.setCollideWorldBounds(true);
        g.setVelocityX(-100);
        g.body.allowGravity = false; 
        g.setBounce(1);
    }

    function update(time, delta) {
        if (isGameOver) return;

        player.setVelocityX(0);
        const isLeft = moveLeft || cursors.left.isDown;
        const isRight = moveRight || cursors.right.isDown;
        const isJump = jump || cursors.up.isDown || cursors.space.isDown;
        const isShoot = shoot;
        
        const keyZ = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);

        if (isLeft) {
            player.setVelocityX(-300);
            player.anims.play('left', true);
            facingRight = false;
        } else if (isRight) {
            player.setVelocityX(300);
            player.anims.play('right', true);
            facingRight = true;
        } else {
            player.anims.play('turn');
        }

        if (isJump && (player.body.touching.down || player.body.blocked.down)) {
            player.setVelocityY(-800);
            jump = false; 
        }

        if ((isShoot || keyZ.isDown) && time > lastFired) {
            if (ammo > 0) {
                let r = rocks.get(player.x, player.y);
                if (r) {
                    r.setActive(true).setVisible(true);
                    r.body.allowGravity = true;
                    r.setVelocity(facingRight ? 600 : -600, -200);
                    ammo--;
                    lastFired = time + 400;
                    txtAmmo.setText('ROCAS: ' + ammo);
                }
            }
        }
    }

    function takeDamage() {
        lives--;
        txtLives.setText('VIDAS: ' + lives);
        player.setTint(0xff0000);
        player.setVelocityY(-400);
        player.x = 100; // Checkpoint inicial
        
        this.time.delayedCall(500, () => player.clearTint());

        if (lives <= 0) {
            isGameOver = true;
            this.physics.pause();
            alert("锔 GAME OVER 锔");
            location.reload();
        }
    }

    function killGhost(r, g) { r.destroy(); g.destroy(); }
    function winGame() { this.physics.pause(); alert(" GANASTE "); location.reload(); }

</script>
</body>
</html>
