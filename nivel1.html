<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nivel 1 - Vertical</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>

<script>
    const config = {
        type: Phaser.AUTO,
        // CAMBIO: Resoluci√≥n VERTICAL para llenar la pantalla del celular
        width: 360,
        height: 640,
        backgroundColor: '#111',
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH
        },
        input: { activePointers: 3 },
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 1000 },
                debug: false
            }
        },
        scene: { preload: preload, create: create, update: update }
    };

    // VARIABLES
    let player, platforms, door, keyItem;
    let cursors; 
    let spikes;
    let uiContainer;
    
    // ESTADO
    let lives = 3;
    let hasKey = false;
    let isGameOver = false;

    // CONTROLES
    let moveLeft = false, moveRight = false, jump = false;

    // UI
    let txtLives, txtInfo;

    const game = new Phaser.Game(config);

    function preload() {
        // --- CARGA DE IM√ÅGENES (Desde carpeta 'fotos') ---
        // Aseg√∫rate de que los nombres coincidan exactamente con tus archivos
        this.load.image('bloque', 'fotos/bloque.png');
        this.load.image('suelo', 'fotos/suelo.png');
        this.load.image('puerta', 'fotos/puerta.png');
        this.load.image('llave', 'fotos/llave.png');
        // Si no tienes imagen de pincho, usaremos un gr√°fico generado abajo
    }

    function create() {
        // Generador de gr√°ficos de respaldo (por si faltan im√°genes o para pinchos)
        let g = this.make.graphics({x:0, y:0, add: false});

        // Pincho (Tri√°ngulo Rojo)
        g.clear(); g.fillStyle(0xff0000, 1);
        g.beginPath(); g.moveTo(0, 32); g.lineTo(16, 0); g.lineTo(32, 32); g.closePath(); g.fillPath();
        g.generateTexture('spikeTex', 32, 32);

        // Personaje (Color Variable del Men√∫)
        let savedColor = localStorage.getItem('skinColor') || '0x00ffff';
        let playerColor = parseInt(savedColor, 16);
        g.clear(); g.fillStyle(playerColor, 1); g.fillRect(0, 0, 24, 36); 
        g.generateTexture('dudeTex', 24, 36);

        // --- 1. L√çMITES Y FONDO ---
        // El juego usa 640px de alto.
        // Zona de juego: 0 a 540px.
        // Zona de botones (negra): 540px a 640px.
        this.physics.world.setBounds(0, 0, 360, 540); 

        // --- 2. DISE√ëO DEL NIVEL (VERTICAL) ---
        platforms = this.physics.add.staticGroup();
        spikes = this.physics.add.staticGroup();

        // SUELO BASE (Imagen √∫nica estirada)
        // Ajustamos la posici√≥n Y para que est√© justo encima de los botones
        let suelo = platforms.create(180, 530, 'suelo'); 
        suelo.displayWidth = 360; // Ancho total de pantalla
        suelo.displayHeight = 40; // Altura del suelo
        suelo.refreshBody();

        // PAREDES INVISIBLES (Para que no se salga por los lados)
        // Izquierda
        let wallL = platforms.create(-10, 270, null);
        wallL.displayWidth = 20; wallL.displayHeight = 540; wallL.refreshBody();
        // Derecha
        let wallR = platforms.create(370, 270, null);
        wallR.displayWidth = 20; wallR.displayHeight = 540; wallR.refreshBody();
        // Techo
        let wallT = platforms.create(180, -10, null);
        wallT.displayWidth = 360; wallT.displayHeight = 20; wallT.refreshBody();


        // --- PLATAFORMAS DE BLOQUES ---
        // Funci√≥n: createTilePlatform(x, y, cantidad_bloques)
        
        // Piso 1
        createTilePlatform(this, 100, 430, 3); // Izquierda
        createTilePlatform(this, 260, 430, 3); // Derecha

        // Piso 2 (Centro con trampa)
        createTilePlatform(this, 180, 330, 4);
        spikes.create(180, 314, 'spikeTex');

        // Piso 3
        createTilePlatform(this, 80, 230, 3);
        createTilePlatform(this, 280, 230, 3);

        // Piso 4 (Meta)
        createTilePlatform(this, 180, 130, 5);


        // --- 3. OBJETIVOS ---
        
        // LLAVE (Ahora con f√≠sica est√°tica para que no caiga)
        // La ponemos en una plataforma alta (ej: Piso 3 izq)
        keyItem = this.physics.add.image(80, 200, 'llave');
        keyItem.body.allowGravity = false; // ¬°CORRECCI√ìN! Ya no se cae
        // Efecto flotante suave
        this.tweens.add({
            targets: keyItem,
            y: keyItem.y - 10,
            duration: 1000,
            yoyo: true,
            repeat: -1
        });
        
        // PUERTA (Imagen 'puerta.png')
        // La ponemos en la cima
        door = this.physics.add.staticImage(180, 95, 'puerta');
        
        // JUGADOR
        player = this.physics.add.sprite(180, 480, 'dudeTex');
        player.setBounce(0.1);
        player.setCollideWorldBounds(true);

        // --- 4. COLISIONES ---
        this.physics.add.collider(player, platforms);
        
        this.physics.add.overlap(player, spikes, takeDamage, null, this);
        this.physics.add.overlap(player, keyItem, collectKey, null, this);
        this.physics.add.overlap(player, door, enterDoor, null, this);

        // --- 5. CONTROLES ---
        cursors = this.input.keyboard.createCursorKeys();
        createInterface(this);
    }

    // --- FUNCI√ìN PARA CREAR PLATAFORMAS CON BLOQUES REPETIDOS ---
    function createTilePlatform(scene, x, y, numBlocks) {
        // Tama√±o del bloque (ajusta seg√∫n tu imagen, ej: 32px)
        const blockSize = 32; 
        
        // Calculamos el inicio para centrar la plataforma en X
        let startX = x - ((numBlocks * blockSize) / 2) + (blockSize / 2);

        for (let i = 0; i < numBlocks; i++) {
            platforms.create(startX + (i * blockSize), y, 'bloque');
        }
    }

    function update() {
        if (isGameOver) return;

        player.setVelocityX(0);

        const isLeft = moveLeft || cursors.left.isDown;
        const isRight = moveRight || cursors.right.isDown;
        const isJump = jump || cursors.up.isDown || cursors.space.isDown;

        if (isLeft) {
            player.setVelocityX(-200);
        } else if (isRight) {
            player.setVelocityX(200);
        }

        if (isJump && (player.body.touching.down || player.body.blocked.down)) {
            player.setVelocityY(-550);
            jump = false; 
        }

        txtLives.setText('VIDAS: ' + lives);
    }

    function takeDamage() {
        lives--;
        player.setTint(0xff0000);
        player.setVelocityY(-300);
        player.x = 180; player.y = 480; // Reset
        
        this.time.delayedCall(500, () => player.clearTint());

        if (lives <= 0) {
            gameOver("üíÄ INT√âNTALO DE NUEVO");
        }
    }

    function collectKey(player, key) {
        key.disableBody(true, true);
        hasKey = true;
        door.setTint(0x00ff00); // Se pone verde
        txtInfo.setText("¬°VE A LA PUERTA!");
    }

    function enterDoor() {
        if (hasKey) {
            gameOver("üèÜ ¬°NIVEL COMPLETADO!");
            // window.location.href = "nivel2.html";
        } else {
            txtInfo.setText("üîí FALTA LLAVE");
        }
    }

    function gameOver(msg) {
        isGameOver = true;
        this.physics.pause();
        alert(msg);
        location.reload();
    }

    // --- INTERFAZ VERTICAL (AJUSTADA A 360px DE ANCHO) ---
    function createInterface(scene) {
        uiContainer = scene.add.container(0, 0).setScrollFactor(0).setDepth(9999);

        // Barra Info
        let topBar = scene.add.graphics();
        topBar.fillStyle(0x000000, 0.7);
        topBar.fillRect(0, 0, 360, 30);
        uiContainer.add(topBar);

        txtLives = scene.add.text(10, 5, 'VIDAS: 3', { fontSize: '16px', color: '#ff4444', fontStyle: 'bold' });
        txtInfo = scene.add.text(150, 5, 'BUSCA LA LLAVE', { fontSize: '14px', color: '#ffff00' });
        uiContainer.add([txtLives, txtInfo]);

        // Zona Botones (Abajo)
        let bottomBar = scene.add.graphics();
        bottomBar.fillStyle(0x111111, 1);
        bottomBar.fillRect(0, 540, 360, 100);
        bottomBar.lineStyle(2, 0x00ff00);
        bottomBar.lineBetween(0, 540, 360, 540);
        uiContainer.add(bottomBar);

        const btnY = 590; 

        // Botones m√°s compactos para pantalla vertical
        let btnL = createBtn(scene, 60, btnY, '<', 0x333333, () => moveLeft=true, () => moveLeft=false);
        let btnR = createBtn(scene, 140, btnY, '>', 0x333333, () => moveRight=true, () => moveRight=false);
        
        let btnJ = createBtn(scene, 290, btnY, 'JUMP', 0xaa0000, () => jump=true, () => jump=false, 40);

        uiContainer.add([btnL, btnR, btnJ]);
    }

    function createBtn(scene, x, y, text, color, downFn, upFn, radius = 35) {
        let btn = scene.add.container(x, y);
        let circle = scene.add.circle(0, 0, radius, color).setStrokeStyle(2, 0xffffff);
        let fontSize = text.length > 2 ? '14px' : '20px';
        let label = scene.add.text(-10, -10, text, { fontSize: fontSize, fontStyle: 'bold' });
        if(text.length > 2) label.x = -18; 
        
        let hit = scene.add.circle(0, 0, radius + 10, 0x000000, 0).setInteractive();
        hit.on('pointerdown', () => { downFn(); btn.y += 4; });
        hit.on('pointerup', () => { upFn(); btn.y -= 4; });
        hit.on('pointerout', () => { upFn(); btn.y -= 4; });

        btn.add([circle, label, hit]);
        return btn;
    }
</script>

</body>
</html>
